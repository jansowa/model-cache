<h1>PODSUMOWANIE BADANIA</h1>
<h2>WYBÓR KONKRETNYCH TECHNOLOGII</h2>
<h3>Relacyjna baza danych</h3>
SQLite to według wielu użytkowników jedna z najszybszych dostępnych baz SQL. Dodatkowo zapisuje wszystkie dane w jednym pliku, nie wymaga serwera ani dodatkowego oprogramowania poza biblioteką dołączoną do projektu. Kolejną zaletą może być wsparcie innych języków programistycznych.
<h3>Nierelacyjna baza danych</h3>
Tak jak w przypadku bazy relacyjnej potrzebujemy bazy szybkiej, zapisującej się w jednym pliku i nie wymagającej dodatkowego oprogamowania. Taką bazą jest Nitrite.
<h3>Pliki tymczasowe</h3>
Jednym z najpopularniejszych pakietów operacji na plikach nieco bardziej rozbudowanych od java.io.File jest org.apache.commons.io.FileUtils. Biblioteka ta ma dobrą dokumentację, sporo tematów na forach i niezłą wydajność. Dodatkowo przyda się pakiet odpowiedzialny za pracę na nazwach plików i ich ścieżkach org.apache.commons.io.FilenameUtils.
<h3>Serializacja obiektów Java</h3>
Nasuwają się dwie możliwości - przechowywanie metadanych o każdym pliku w osobnym serializowaym obiekcie lub serializowanie obiektu ze strukturą danych z pożądanymi informacjami. Pierwsze rozwiązanie wydaje się niepotrzebnie zawiłe, dodatkowo mocno przypomina opcję plików tymczasowych, jednak zawiera zbędne opakowanie na metadane w postaci obiektu. Pozostaje serializowanie stuktur danych - optymalne wydaję się listy i mapy. Ze względu na konieczność odwoływania się do zapisów w różnej kolejności najlepszym wyborem jest ArrayLista i HashMapa. Do procesu serializacji nie są potrzebne wyszukane biblioteki - wystarczą paczki z java.io

<h3>Uwaga dodatkowa</h3>
Model Cache korzystający z repozytorium obiektów bazy Nitrite niestety nie mógł korzystać z FileBasicInfo. Takie repozytorium potrzebuje mutowalnego obiektu z odpowiednimi konstruktorami. Był to ostatni implementowany model - w tej sytuacji refaktoryzacja wszystkich pozostałych, żeby korzystała z odpowiedniego obiektu byłaby czasochłonna i mało wnosząca. Według twórcy Nitrite zapis w repozytoriach obiektów jest nieco wolniejszy niż korzystanie z dokumentów - stąd można przybliżyć jego spodziewaną wydajność w rankingu.

<h2>ANALIZA ROZWIĄZAŃ</h2>
<h3>Analiza wydajności</h3>
Zwycięzcą pod względem każdej operacji został model z **plikami tymczasowymi** i zależnie od konkretnego wykonania jest przynajmniej 2-3 krotnie szybszy od innych rozwiązań. Drugie i trzecie miejsce to kolejno model SQLite z jedną tabelą dla wszystkich rekordów i ex aequo Nitrite z dokumentami oraz SQLite z wieloma tabelami (z ostatnich dwóch rozwiązań raz jedno, raz drugie jest szybsze - zależnie od konkretnego uruchomienia).

<h3>Analiza czytelności, ilości kodu</h3>
Najprostszy i najczytelniejszy okazał się model **nierelacyjnej bazy danych z repozytorium obiektów**. Z drugiej strony obydwie implementacje oparte na SQLite - mają masę boilerplate code, bardzo łatwo pomylić się przy pisaniu kodu, modyfikacji, debuggowanie również nie jest proste (dodatkowo rozwiązanie z wieloma bazami komplikuje sytuacje i wprowadza około połowy kodu więcej). Pomiędzy najlepszą i najgorszą opcją mamy resztę propozycji - wszystkie mają podobną długość kodu, czytelność, przy czym wyróżniłbym nieco pliki tymczasowe - prawie nie wymagają użycia struktur danych, znajomości żadnej bazy danych, a większość funkcjonalności to tylko odwołanie się do funkcji już zaimplementowanej w intuicyjnej bibliotece z obsługą plików.

<h3>Analiza objętości danych</h3>
Tutaj znów zdecydowanie najlepiej wypada implementacja z **plikami tymczasowymi**. Informacje o 100 plikach zawierają 2-4 razy mniej miejsca niż w innych rozwiązaniach. Modele z serializacją i nierelacyjną bazą danych potrzebują nieco więcej miejsca (około dwukrotnie), najgorzej pod tym względem wypadają modele SQLite - baza z wieloma tabelami to około 3 krotnie większy rozmiar od plików tymczasowych, baza z jedną tabelą - około cztery razy większa.

<h3>Analiza pod względem urządzeń mobilnych</h3>
Każde z rozwiązań umożliwia zastosowanie na urządzeniach mobilnych. W przypadku Nitrite i SQLite całe bazy zapisywane są w pojedynczym pliku, ich odczyt nie wymaga serwera, instalacji dodatkowego oprogramowania - wystarczy załączenie pojedynczej biblioteki. Serializacja struktur danych nie wymaga nawet dodatkowych bibliotek. Model z **plikami tymczasowymi** również nie wymaga dodatkowego softu, jego dodatkowym plusem jest to, że jest w dużym stopniu niezależny od technologii - bardzo prosto można korzystać z jego zapisów poprzez implementację napisaną nawet w innym języku. To rozwiązanie posiada pod tym względem tylko jedną drobną wadę - podczas przenoszenia modelu pomiędzy urządzeniami musimy przenieść całą strukturę katalogów i plików, w przeciwieństwie do pojedynczego pliku - tak jak w pozostałych przypadkach.

|                                          | Sposób zapisu plików                                                                                                                                                       | Wydajność (miejsce) | Czytelność kodu                                                                                                                                                                                                                                                                   | Objętość 100 plików (miejsce) |
|------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------|
| Serializacja ArrayListy                  | Utworzyłem obiekt zawierający ArrayListę, do której dodałem obiekty z metadanymi plików. Zapisałem na dysku za pomocą serializacji.                                        | (6)                 | Bardzo prosty, czytelny kod                                                                                                                                                                                                                                                       | 11931 bajtów (2)              |
| Serializacja HashMapy                    | Utworzyłem obiekt zawierający HashMapę, której kluczami są ścieżki do plików, a wartościami obiekty z metadanymi plików. Zapisałem na dysku za pomocą serializacji.        | (5)                 | Bardzo prosty, czytelny kod                                                                                                                                                                                                                                                       | 12455 bajtów (4)              |
| Relacyjna baza danych z jedną tabelą     | Utworzyłem jedną tabelę w SQLite, której kolumny to kolejne metadane pliku, a rekordy reprezentują kolejne pliki.                                                          | (2)                 | Dużo boilerplate code powiązanego z zapytaniami SQL, nawiązywaniem połączeń.                                                                                                                                                                                                      | 20480 bajtów (6)              |
| Relacyjna baza danych z wieloma tabelami | Utworzyłem po jednej tabeli od nazw folderów zawierających pliki w bazie SQLite. W każdej tabeli kolumny reprezentują kolejne metadane plików (poza ścieżką).              | (3)                 | Dużo boilerplate code powiązanego z zapytaniami SQL, nawiązywaniem połączeń, dodatkowe skomplikowanie funkcji przez wprowadzenie wielu tabel                                                                                                                                      | 16384 bajtów (5)              |
| Pliki tymczasowe                         | Model reprezentuje naturalny rozkład katalogów i plików w chmurze. Zamiast pełnych plików mamy w nich String z URL i datą utworzenia w czasie unikowym w kolejnej linijce. | (1)                 | Minimalnie dłuższy kod od pozostałych rozwiązań (poza wersją SQL), jednak bardzo prosty. Potrzebną funkcjonalność umożliwiają łatwe i popularne biblioteki, dodatkowo większość popularnych technologii ma znane biblioteki do obsługi plików, co mocno ułatwiłoby przepisywanie. | 5890 bajtów (1)               |
| Nierelacyjna baza danych z dokumentami   | Utworzyłem jedną kolekcję w Nitrite. Każdy dokument zawiera metadane dotyczące jednego pliku, ścieżka ma identyfikator dla szybszego wyszukiwania.                         | (4)                 | Prosty i bardzo krótki kod (nieco dłuższy wyłącznie od drugiej wersji z bazą danych Nitrite)                                                                                                                                                                                      | 12288 bajtów (3)              |
| Nierelacyjna baza danych z obiektami     | Model zawiera repozytorium obiektów. Każdy obiekt przedstawia metadane dotyczące jednego pliku, ścieżka ma identyfikator dla szybszego wyszukiwania.                       | (gorsze niż 4)      | Bardzo prosty i najkrótszy ze wszystkich propozycji kod                                                                                                                                                                                                                           |                               |

<h2>Dodatkowe informacje dotyczące implementacji</h2>
Moja implementacja zawiera uproszczone modele, które dla ułatwienia korzystają z niemutowalnego obiektu FileBasicInfo (poza rozwiązaniem Nitrite z repozytorium obiektów. Z tego powodu niektóre implementacje mogą mieć pewne drobne usprawnienia, przede wszystkim brak nadmiarowych danych.
<br><br>We wszystkich modelach poza plikami tymczasowymi i HashMapą (o tej ostatniej dalej) warto pomyśleć nad zmianą zapisywanego obiektu. Obecnie pole filePath zawiera w sobie nazwę pliku i jego rozszerzenie. W takiej sytuacji zmiana pola filePath na parent lub usunięcie pól name i extension zmniejszyłoby rozmiar danych. W obydwu przypadkach niezbędna byłaby implementacja dodatkowych funkcji (wyciągającej z filePath nazwę i rozszerzenie lub łącząca pola parent, name i extension w pełną ścieżkę pliku).
<br><br>Serializowanie HashMapy
<br>Tutaj klucz HashMapy zawiera pełną ścieżkę do pliku, więc można rozwarzyć usunięcie z wartości aż trzech pól - filePath, name i extension.
<br><br>Pliki tymczasowe
<br>W niektórych sytuacjach opłacalne może okazać się przechowywanie danych wewnątrz plików jako JSON lub XML - zwiększy to objętość plików, jednak ułatwi wyciąganie informacji.
<h2> Wyłonienie zwycięzcy</h2>
Przy zdecydowanej większości kryteriów model plików tymczasowych jest zwycięzcą lub jest jednym z lepszych opcji. Niezależnie od tego w jaki sposób będą tworzone klienty dla Raicoone rozwiązanie te okaże się szybkie, proste w implementacji, modyfikacji i będzie zawierało małą objętość.